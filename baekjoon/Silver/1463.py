'''
[다이나믹 프로그래밍] :
구현법 1. 메모이제이션(하향식_Topdown) -> 재귀함수 (큰 문제를 풀기 위해 작은 문제들을 호출)
구현법 2. 보텀업(상향식) -> 작은 문제부터 풀어서 나감

* (1로 만들기 (실3))
1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.

goal: 저 3가지를 적절히 사용해 결과를 1을 만들되, 연산 사용 횟수의 최솟값을 구해라
'''
# [3] = dp[2]+1
#     = dp[1]+1 +1
#     = 0 +1 +1


n = int(input())

dp = [0] * (n+1) #연산 사용 횟수

for i in range(2,n+1): #dp[1] = 0임
    #1. 2,3으로 나눠지지 않을 경우를 위해 먼저 +1
    dp[i] = dp[i-1] + 1

    #2. 2,3으로 나눠지는 경우였다면
    if i % 2 == 0:
        #비교하자 더 최솟값인 것을
        # ex) 위에선 dp[3]= 2 이지만, 최소로 dp[3] = 1이다(나눠짐)
        dp[i] = min(dp[i], dp[i//2]+1)
    #? 왜 if일까? ex) 6의 경우엔 한 번 더 나눠줘야 함(공약수)
    if i % 3 == 0:
        dp[i] = min(dp[i], dp[i//3]+1)

print(dp[n])

